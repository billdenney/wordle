is_elsewhere <- (wordle_has_letter_df[, current_letter] > 0) & !is_here
wordle_has_letter_df[, current_letter] <- wordle_has_letter_df[, current_letter] - is_elsewhere
states <- states + 10^(nchar(current_guess) - idx)*is_elsewhere
}
as.integer(states)
}
wordle_guess_colors <- function(current_guess, correct_word, wordle_has_letter_df) {
states <- rep(0, nrow(wordle_has_letter_df))
stopifnot(all(correct_word %in% rownames(wordle_has_letter_df)))
# First check for the letter being in the current position, if so, make it
# "green" (=2), and remove one from the other location options
for (idx in seq_len(nchar(current_guess))) {
current_letter <- substr(current_guess, idx, idx)
is_here <- wordle_has_letter_df[correct_word, paste0(current_letter, idx)]
wordle_has_letter_df[correct_word, current_letter] <- wordle_has_letter_df[correct_word, current_letter] - is_here
states <- states + 10^(nchar(current_guess) - idx)*is_here*2
}
browser()
for (idx in seq_len(nchar(current_guess))) {
current_letter <- substr(current_guess, idx, idx)
is_here <- wordle_has_letter_df[correct_word, paste0(current_letter, idx)]
is_elsewhere <- (wordle_has_letter_df[correct_word, current_letter] > 0) & !is_here
wordle_has_letter_df[correct_word, current_letter] <- wordle_has_letter_df[correct_word, current_letter] - is_elsewhere
states <- states + 10^(nchar(current_guess) - idx)*is_elsewhere
}
as.integer(states)
}
#' Generate a data.frame of "colors" where the first column are the possible
#' words to guess and the remaining columns are the colors generated by the
#' guessed word.
#'
#' @inheritParams wordle_guess_colors
wordle_guess_colors_df <- function(possible, all_words) {
wordle_has_letter_df <- wordle_has_letter_setup(possible)
all_words <- sort(unique(c(possible, all_words)))
ret <- data.frame(X=possible)
pb <- txtProgressBar(min=0, max=length(all_words), style=3)
for (current_all in all_words) {
setTxtProgressBar(pb, value=getTxtProgressBar(pb) + 1)
browser()
ret[[current_all]] <-
wordle_guess_colors(
current_guess=current_all,
wordle_has_letter_df=wordle_has_letter_df
)
}
ret
}
new_wordle_game <- function(correct_word, possible_df, expected_char=5) {
stopifnot(is.character(correct_word))
stopifnot(length(correct_word) == 1)
stopifnot(nchar(correct_word) == expected_char)
list(
correct=correct_word,
possible_df=possible_df,
available_rows=rep(TRUE, nrow(possible_df)),
available_cols=c(FALSE, rep(TRUE, ncol(possible_df) - 1))
)
}
wordle_game_state <- function(game_state, guess, verbose=TRUE) {
guess_value <- game_state$possible_df[game_state$possible_df$X == game_state$correct, guess]
history_new <- setNames(guess_value, guess)
game_state$history <- c(game_state$history, history_new)
game_state$available_rows <- game_state$available_rows & game_state$possible_df[, guess] == guess_value
# game_state$available_cols <-
#   (names(game_state$available_cols) %in% game_state$possible_df$X)
if (verbose) {
message(
"Number of possible words: ", sum(game_state$available_rows), "\n",
"Number of possible guesses: ", sum(game_state$available_cols), "\n",
"History: ", paste(names(game_state$history), game_state$history, sep="=", collapse=", ")
)
}
game_state
}
wordle_choose_guess <- function(game_state, metric_fun, verbose=TRUE) {
possible_words <- game_state$possible_df[[1]][game_state$available_rows]
if (length(possible_words) < 3) {
# If there are two choices, guess
return(setNames(rep(-Inf, length(possible_words)), possible_words))
}
if (!is.list(metric_fun)) {
metric_fun <- list(metric_fun)
}
if (verbose) {
pb <- txtProgressBar(min=0, max=sum(game_state$available_cols), style=3)
pb_metric_fun <- function(...) {
setTxtProgressBar(pb, value=getTxtProgressBar(pb) + 1)
metric_fun[[1]](...)
}
} else {
pb_metric_fun <- metric_fun[[1]]
}
metrics <-
sapply(
# operate only on the available rows from the available columns
X=game_state$possible_df[game_state$available_cols][game_state$available_rows, ],
FUN=pb_metric_fun
)
# First prioritize improved metrics.  Then prioritize words that are possible
# (so that you can get it in 1 more).
ret_metrics <- metrics[order(metrics, -(names(metrics) %in% possible_words))]
# If there are more than one metric functions defined, break top-level ties with the next metric function
mask_equal_to_best <- ret_metrics == ret_metrics[[1]]
if ((length(metric_fun) > 1) & sum(mask_equal_to_best) > 1) {
metrics2 <-
sapply(
# operate only on the available rows from the available columns
X=game_state$possible_df[names(ret_metrics)][game_state$available_rows, ],
FUN=metric_fun[[2]]
)
ret <- ret_metrics[mask_equal_to_best][order(metrics2)]
} else {
ret <- ret_metrics
}
ret
}
wordle_choose_guess_cache <- function(metric_fun) {
cache <- force(list())
metric_fun <- force(metric_fun)
function(game_state, verbose) {
history_chr <- paste(names(game_state$history), game_state$history, sep="=", collapse=", ")
if (history_chr %in% names(cache)) {
if (verbose) message("Using cache for ", history_chr, ": ", names(cache[[history_chr]]))
} else {
# Only store the first guess, since that is all that is used.
cache[[history_chr]] <<- wordle_choose_guess(game_state=game_state, metric_fun=metric_fun, verbose=verbose)[1]
}
cache[[history_chr]]
}
}
# Autoplay ####
wordle_autoplay <- function(game_state, guess_fun, initial_guess, verbose_guess=FALSE, verbose_state=FALSE) {
game_state <- wordle_game_state(game_state, guess=initial_guess, verbose=verbose_state)
while (game_state$history[length(game_state$history)] != 22222) {
current_guess <- guess_fun(game_state=game_state, verbose=verbose_guess)
game_state <- wordle_game_state(game_state, guess=names(current_guess)[1], verbose=verbose_state)
}
message(
"Game complete for ", game_state$correct, "; ", length(game_state$history), " guesses; ",
paste(names(game_state$history), game_state$history, sep="=", collapse=", ")
)
game_state
}
# Word selection metrics ####
wordle_metric_smallest_big_group <- function(x) {
max(summary(factor(x)))
}
wordle_metric_most_to_median_group <- function(x) {
sf <- rev(sort(summary(factor(x))))
-unname(which(cumsum(sf) > (length(x)/2))[1])
}
wordle_metric_smallest_median_group <- function(x) {
sf <- sort(summary(factor(x)))
unname(sf[which(cumsum(sf) > (length(x)/2))[1]])
}
guess_cache_smallest_big_group <- wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
guess_cache_smallest_median_group <- wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_median_group)
guess_cache_smallest_big_then_median_group <- wordle_choose_guess_cache(metric_fun=list(wordle_metric_smallest_big_group, wordle_metric_smallest_median_group))
# Game Setup ####
words <- load_wordle_word_lists()
setwd("C:/tmp")
devtools::create(path="wordle")
setwd("wordle/")
usethis::use_data_raw(name="wordle_colors")
usethis::use_data_raw("wordlists")
devtools::load_all()
devtools::load_all()
# code to prepare `wordlists` dataset goes here
wordlists <- load_wordle_word_lists()
usethis::use_data(wordlists, overwrite = TRUE)
wordlists
names(wordlists)
## code to prepare `wordle_colors` dataset goes here
wordle_colors <- wordle_guess_colors_df(possible=words$possible, all_words=words$all)
## code to prepare `wordle_colors` dataset goes here
wordle_colors <- wordle_guess_colors_df(possible=wordlists$possible, all_words=wordlists$all)
wordle_guess_colors(
current_guess=current_all,
wordle_has_letter_df=wordle_has_letter_df
)
current_guess
states <- setNames(rep(0, nrow(wordle_has_letter_df)), rownames(wordle_has_letter_df))
# First check for the letter being in the current position, if so, make it
# "green" (=2), and remove one from the other location options
for (idx in seq_len(nchar(current_guess))) {
current_letter <- substr(current_guess, idx, idx)
is_here <- wordle_has_letter_df[, paste0(current_letter, idx)]
wordle_has_letter_df[, current_letter] <- wordle_has_letter_df[, current_letter] - is_here
states <- states + 10^(nchar(current_guess) - idx)*is_here*2
}
states["arrive"]
names(states)
head(names(states))
states["awake"]
for (idx in seq_len(nchar(current_guess))) {
current_letter <- substr(current_guess, idx, idx)
is_here <- wordle_has_letter_df[, paste0(current_letter, idx)]
is_elsewhere <- (wordle_has_letter_df[, current_letter] > 0) & !is_here
wordle_has_letter_df[, current_letter] <- wordle_has_letter_df[, current_letter] - is_elsewhere
states <- states + 10^(nchar(current_guess) - idx)*is_elsewhere
}
states["awake"]
current_guess
wordle_has_letter_df["awake", "a"]
devtools::load_all()
## code to prepare `wordle_colors` dataset goes here
wordle_colors <- wordle_guess_colors_df(possible=wordlists$possible, all_words=wordlists$all)
wordle_has_letter_df_current["awake", "a"]
states["awake"]
for (idx in seq_len(nchar(current_guess))) {
current_letter <- substr(current_guess, idx, idx)
is_here <- wordle_has_letter_df_current[, paste0(current_letter, idx)]
is_elsewhere <- (wordle_has_letter_df_current[, current_letter] > 0) & !is_here
browser()
wordle_has_letter_df_current[, current_letter] <- wordle_has_letter_df_current[, current_letter] - is_elsewhere
states <- states + 10^(nchar(current_guess) - idx)*is_elsewhere
}
is_elsewhere["awake"]
is_elsewhere["awake"]
is_elsewhere[rownames(wordle_has_letter_df_current) %in% "awake"]
print(idx)
wordle_has_letter_df_current["awake", current_letter]
is_here[rownames(wordle_has_letter_df_current) %in% "awake"]
is_elsewhere[rownames(wordle_has_letter_df_current) %in% "awake"]
print(idx)
is_elsewhere[rownames(wordle_has_letter_df_current) %in% "awake"]
states["awake"]
10^(nchar(current_guess) - idx)*is_elsewhere
10^(nchar(current_guess) - idx)*is_elsewhere[rownames(wordle_has_letter_df_current) %in% "awake"]
states["awake"]
states["awake"]
states["awake"]
devtools::load_all()
## code to prepare `wordle_colors` dataset goes here
wordle_colors <- wordle_guess_colors_df(possible=wordlists$possible, all_words=wordlists$all)
wordle_colors["awake", "aahed"]
wordle_colors["aahed", "awake"]
names(wordle_colors)
head(names(wordle_colors), 20)
rownames(wordle_colors)
devtools::load_all()
## code to prepare `wordle_colors` dataset goes here
wordle_colors <- wordle_guess_colors_df(possible=wordlists$possible, all_words=wordlists$all)
wordle_colors["aahed", "awake"]
wordle_colors["awake", "aahed"]
wordle_colors["awake", "brave"]
wordle_colors["awake", "noses"]
wordle_colors["awake", "faces"]
wordle_colors["faces", "awake"]
devtools::document()
usethis::use_data(wordle_colors, overwrite = TRUE)
use_gpl3_license()
usethis::use_gpl3_license()
devtools::document(
)
devtools::document()
usethis::use_testthat()
usethis::use_test()
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade"))
expect_equal(
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade")),
data.frame(
X=c("awake", "evade"),
aahed=c( 20101,   10011),
awake=c( 22222,   10002),
evade=c( 202,   22222)
)
)
library(testthat)
test_that("", {
expect_equal(
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade")),
data.frame(
X=c("awake", "evade"),
aahed=c( 20101,   10011),
awake=c( 22222,   10002),
evade=c( 202,   22222)
)
)
})
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade"))
expect_equal(
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade")),
data.frame(
X=    c("awake", "evade"),
aahed=c( 21010,   10011),
awake=c( 22222,   10002),
evade=c( 00202,   22222)
)
)
expect_equal(
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade")),
data.frame(
X=    c("awake", "evade"),
aahed=c( 21010,   10011),
awake=c( 22222,   00202),
evade=c( 00202,   22222)
)
)
expect_equal(
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade")),
setNames(
data.frame(
X=    c("awake", "evade"),
aahed=c( 21010,   10011),
awake=c( 22222,   00202),
evade=c( 00202,   22222)
),
c("awake", "evade")
)
)
?data.frame
expect_equal(
wordle_guess_colors_df(possible=c("awake", "evade"), all_words=c("aahed", "awake", "evade")),
data.frame(
X=    c("awake", "evade"),
aahed=c( 21010,   10011),
awake=c( 22222,   00202),
evade=c( 00202,   22222),
row.names=c("awake", "evade")
)
)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
?wordle_metric
usethis::use_package_doc()
?use_package_doc
wordle_colors$X
devtools::document()
?wordle
devtools::document()
?wordle-package
?"wordle-package"
pb_all_words <- txtProgressBar(min=0, max=nrow(wordle_colors), style=3)
# Setup your guessing cache
guess_cache_smallest_big_group <-
wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
# Save your valuable output
ret <- list()
# Play all games
for (current_word in sort(wordle_colors$X)) {
setTxtProgressBar(
pb_all_words,
value=getTxtProgressBar(pb_all_words) + 1, title="All words"
)
ret[[current_word]] <-
wordle_autoplay(
game_state=new_wordle_game(correct_word=current_word),
guess_fun=wordle:::guess_cache_smallest_big_group,
initial_guess="raise"
)
}
sum(game_state$available_rows)
available_cols_original <- game_state$available_cols
for (idx in which(game_state$available_cols)) {
current_col_available_rows <- game_state$possible_df[[idx]][game_state$available_rows]
if (all(current_col_available_rows == current_col_available_rows[1])) {
game_state$available_cols[idx] <- FALSE
}
}
sum(game_state$available_cols)
sum(available_cols_original)
names(game_state$possible_df)[game_state$available_cols != available_cols_original]
names(game_state$possible_df)[game_state$available_cols != available_cols_original] %in% rownames(game_state$possible_df)
devtools::load_all()
ret[[current_word]] <-
wordle_autoplay(
game_state=new_wordle_game(correct_word=current_word),
guess_fun=wordle:::guess_cache_smallest_big_group,
initial_guess="raise",
verbose_state=TRUE
)
pb_all_words <- txtProgressBar(min=0, max=nrow(wordle_colors), style=3)
# Setup your guessing cache
guess_cache_smallest_big_group <-
wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
# Save your valuable output
ret <- list()
current_word
setTxtProgressBar(
pb_all_words,
value=getTxtProgressBar(pb_all_words) + 1, title="All words"
)
ret[[current_word]] <-
wordle_autoplay(
game_state=new_wordle_game(correct_word=current_word),
guess_fun=wordle:::guess_cache_smallest_big_group,
initial_guess="raise",
verbose_state=TRUE
)
# Setup your guessing cache
guess_cache_smallest_big_group <-
wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
ret[[current_word]] <-
wordle_autoplay(
game_state=new_wordle_game(correct_word=current_word),
guess_fun=guess_cache_smallest_big_group,
initial_guess="raise",
verbose_state=TRUE
)
ret[[current_word]] <-
wordle_autoplay(
game_state=new_wordle_game(correct_word=current_word),
guess_fun=guess_cache_smallest_big_group,
initial_guess="raise",
verbose_state=TRUE, verbose_guess=TRUE
)
# Save your valuable output
ret <- list()
# Play all games
for (current_word in sort(wordle_colors$X)) {
setTxtProgressBar(
pb_all_words,
value=getTxtProgressBar(pb_all_words) + 1, title="All words"
)
ret[[current_word]] <-
wordle_autoplay(
game_state=new_wordle_game(correct_word=current_word),
guess_fun=guess_cache_smallest_big_group,
initial_guess="raise"#,
#verbose_state=TRUE, verbose_guess=TRUE
)
}
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
new_wordle_game(correct_word="pleat")
foo <- new_wordle_game(correct_word="pleat")
names(foo)
foo$history
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
devtools::load_all()
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
devtools::load_all()
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
# Setup your guessing cache
guess_cache_smallest_big_group <-
wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
devtools::load_all()
# Setup your guessing cache
guess_cache_smallest_big_group <-
wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
game_state$history
metric_fun[[1]]
# Setup your guessing cache
guess_cache_smallest_big_group <-
wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
# What is the best first guess?
initial_guess_smallest_big_group <- wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=guess_cache_smallest_big_group)
if (is.null(game_state$history)) {
# Set to nothing if there is no history
history_chr <- ""
} else {
history_chr <- paste(names(game_state$history), game_state$history, sep="=", collapse=", ")
}
game_state
guess_cache_smallest_big_group
# What is the best first guess?
initial_guess_smallest_big_group <-
guess_cache_smallest_big_group(new_wordle_game(correct_word="pleat"), verbose=TRUE)
initial_guess_smallest_big_group
devtools::load_all()
# Setup your guessing cache
guess_cache_smallest_big_group <-
wordle_choose_guess_cache(metric_fun=wordle_metric_smallest_big_group)
# What is the best first guess?
initial_guess_smallest_big_group <-
guess_cache_smallest_big_group(new_wordle_game(correct_word="pleat"), verbose=TRUE)
initial_guess_smallest_big_group
# What is the best first guess?
initial_guess_smallest_big_group <-
wordle_choose_guess(game_state=game_state, metric_fun=wordle_metric_smallest_big_group, verbose=TRUE)
# What is the best first guess?
initial_guess_smallest_big_group <-
wordle_choose_guess(game_state=new_wordle_game(correct_word="pleat"), metric_fun=wordle_metric_smallest_big_group, verbose=TRUE)
initial_guess_smallest_big_group
initial_guess_smallest_big_group[initial_guess_smallest_big_group == min(initial_guess_smallest_big_group)]
pb_all_words <- txtProgressBar(min=0, max=nrow(wordle_colors), style=3)
# Save your valuable output
ret <- list()
# Play all games
for (current_word in sort(wordle_colors$X)) {
setTxtProgressBar(
pb_all_words,
value=getTxtProgressBar(pb_all_words) + 1, title="All words"
)
ret[[current_word]] <-
wordle_autoplay(
game_state=new_wordle_game(correct_word=current_word),
guess_fun=guess_cache_smallest_big_group,
initial_guess="raise"#,
#verbose_state=TRUE, verbose_guess=TRUE
)
}
guess_distribution <- sapply(X=ret, FUN=function(x) length(x$history))
summary(guess_distribution)
summary(factor(guess_distribution))
