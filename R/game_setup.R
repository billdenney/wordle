#' Load the possible word lists from the Wordle source
#' 
#' @param url The javascript source for finding the word lists
#' @param match_possible_words A word that is within the word list for the
#'   possible words (mainly, words that people are likely to know, the Wordle
#'   developer was kind)
#' @param match_all_words A word that is within the word list for all words
#'   (more than just the possible words)
#' @param expected_characters The number of characters expected in every word,
#'   used as a quality check for the outputs
#' @return A named list with names of "possible" and "all" for the possible
#'   and all word lists
load_wordle_word_lists <- function(
    url="https://www.nytimes.com/games/wordle/main.bd4cb59c.js",
    match_possible_words="balmy", match_all_words="aahed",
    expected_characters=5) {
  word_source_raw <- readLines(url)
  ## There are two word lists in the source, one that is allowed words to be the
  ## correct answer, and the other that is all words allowed to be guessed
  two_lists <- c(possible=match_possible_words, all=match_all_words)
  two_lists_l <- list()
  for (current_word_type in names(two_lists)) {
    current_word <- two_lists[[current_word_type]]
    mask <- grepl(x=word_source_raw, pattern=current_word)
    word_source_words_raw <-
      gsub(
        x=word_source_raw[mask],
        pattern=sprintf('^.*\\[([",a-z]*%s[",a-z]*)\\].*$', current_word),
        replacement="\\1"
      )
    #word_source_words_raw <- gsub(x=word_source_raw[mask], pattern='^.*?\\[((?:\\"[a-z]{5}\\",?)+)\\].*?$', replacement="\\1")
    two_lists_l[[current_word_type]] <-
      gsub(x=strsplit(x=word_source_words_raw, split=",")[[1]], pattern='"', replacement="")
  }
  ## All words that are allowed
  words <- unname(unlist(two_lists_l))
  ## All words that are possible
  possible_words <- two_lists_l$balmy
  # Make sure that loading the data worked correctly (all words should have 5 characters)
  stopifnot(all(nchar(words) == expected_characters))
  words[nchar(words) != expected_characters]
  two_lists_l
}

#' Generate a data.frame with all the letter/position for all words
#' 
#' @param word The vector of words (character vector)
#' @return A data.frame with rownames of \code{word} and the first column "word"
#'   containing \code{word}.  Then additional columns for each letter and
#'   letter/position ("a", "a1", "a2", ...) with a boolean indicating if the
#'   letter is in the word or the letter is in the word at the position.
#' @examples
#' wordle_has_letter_setup(c("binge", "splut"))
wordle_has_letter_setup <- function(word) {
  stopifnot(length(unique(nchar(word))) == 1)
  ret <- data.frame(word=word)
  for (current_letter in letters) {
    ret[[current_letter]] <- nchar(gsub(x=word, pattern=sprintf("[^%s]", current_letter), replacement=""))
    for (current_idx in seq_len(nchar(word[1]))) {
      ret[[paste0(current_letter, current_idx)]] <- current_letter == substr(word, current_idx, current_idx)
    }
  }
  rownames(ret) <- word
  ret
}

#' Generate the "colors" for a word guess relative to the possible words
#' 
#' @param guess The word that was guessed
#' @param possible The vector of possible words
#' @return An integer vector where 0 indicates no in the word, 1 indicates
#'   elsewhere in the word, and 2 indicates at the current location in the word.
wordle_guess_colors <- function(current_guess, wordle_has_letter_df) {
  states <- setNames(rep(0, nrow(wordle_has_letter_df)), rownames(wordle_has_letter_df))
  # First check for the letter being in the current position, if so, make it
  # "green" (=2), and remove one from the other location options
  wordle_has_letter_df_current <- wordle_has_letter_df
  for (idx in seq_len(nchar(current_guess))) {
    current_letter <- substr(current_guess, idx, idx)
    is_here <- wordle_has_letter_df_current[, paste0(current_letter, idx)]
    wordle_has_letter_df_current[, current_letter] <- wordle_has_letter_df_current[, current_letter] - is_here
    states <- states + 10^(nchar(current_guess) - idx)*is_here*2
  }
  for (idx in seq_len(nchar(current_guess))) {
    current_letter <- substr(current_guess, idx, idx)
    is_here <- wordle_has_letter_df_current[, paste0(current_letter, idx)]
    is_elsewhere <- (wordle_has_letter_df_current[, current_letter] > 0) & !is_here
    wordle_has_letter_df_current[, current_letter] <- wordle_has_letter_df_current[, current_letter] - is_elsewhere
    states <- states + 10^(nchar(current_guess) - idx)*is_elsewhere
  }
  as.integer(states)
}

#' Generate a data.frame of "colors" where the first column are the possible
#' words to guess and the remaining columns are the colors generated by the
#' guessed word.
#' 
#' @inheritParams wordle_guess_colors 
wordle_guess_colors_df <- function(possible, all_words) {
  wordle_has_letter_df <- wordle_has_letter_setup(possible)
  all_words <- sort(unique(c(possible, all_words)))
  ret <- data.frame(X=possible)
  rownames(ret) <- possible
  pb <- txtProgressBar(min=0, max=length(all_words), style=3)
  for (current_all in all_words) {
    setTxtProgressBar(pb, value=getTxtProgressBar(pb) + 1)
    ret[[current_all]] <-
      wordle_guess_colors(
        current_guess=current_all,
        wordle_has_letter_df=wordle_has_letter_df
      )
  }
  ret
}
